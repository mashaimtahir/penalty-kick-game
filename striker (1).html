<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Model Viewer with Shadows</title>
    <style>
        body { margin: 0; }
        #canvas-container {
            width: 100%;
            height: 400px;
            background-color: #f3f4f6;
            border-radius: 0.5rem;
            overflow: hidden;
        }
    </style>

    <!-- Import map for three.js version 0.168.0 -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/"
        }
      }
    </script>
</head>
<body>
    <div id="canvas-container"></div>

    <!-- JavaScript modules for Three.js, GLTFLoader, DRACOLoader, and OrbitControls -->
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls, model, mixer, animations = {};
        let clock = new THREE.Clock();

        function init() {
            // Set up the scene, camera, and renderer
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / 400, 0.1, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, 400);
            renderer.shadowMap.enabled = true; // Enable shadow maps
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const spotLight = new THREE.SpotLight(0xffffff, 1);
            spotLight.position.set(10, 10, 10);
            spotLight.castShadow = true; // Enable shadow casting
            spotLight.shadow.mapSize.width = 1024;
            spotLight.shadow.mapSize.height = 1024;
            scene.add(spotLight);

          
           
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(-10, 10, -10);
            directionalLight.castShadow = true; // Enable shadow casting
            scene.add(directionalLight);
   // Floor to receive shadows
   const floorGeometry = new THREE.PlaneGeometry(20, 20);
            const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true; // Enable shadow receiving
            scene.add(floor);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);

            // Configure DracoLoader for compressed GLTF files
            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.7/');

            // Load the model using GLTFLoader with Draco compression support
            const gltfLoader = new GLTFLoader();
            gltfLoader.setDRACOLoader(dracoLoader);


            gltfLoader.load(
                'crowd1.glb',  // Path to the stadium-part.glb model
                function (gltf) {
                    const crowdModel = gltf.scene;
                    crowdModel.scale.set(3, 3, 3); // Adjust scale if needed
                    crowdModel.position.set(0, 0, 5);  // Move behind the goal
                    scene.add(crowdModel);
                    crowdModel.traverse((child) => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }
        });   
                },
                undefined,
                function (error) {
                    console.error('An error occurred with the stadium model:', error);
                }
            );
window.addEventListener('resize', onWindowResize, false);
}

function onWindowResize() {
camera.aspect = window.innerWidth / 400;
camera.updateProjectionMatrix();
renderer.setSize(window.innerWidth, 400);
}

function animate() {
requestAnimationFrame(animate);
            if (mixer) mixer.update(clock.getDelta());
            controls.update();
            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>